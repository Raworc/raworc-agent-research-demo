from dotenv import load_dotenv
from pydantic import BaseModel
from langchain_openai import ChatOpenAI
from langchain_anthropic import ChatAnthropic
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import PydanticOutputParser
from langchain.agents import create_tool_calling_agent, AgentExecutor
from tools import get_research_tools
import json
from datetime import datetime
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
import os

load_dotenv()

class ResearchResponse(BaseModel):
    topic: str
    summary: str
    key_points: list[str]
    sources: list[str]
    tools_used: list[str]

llm = ChatAnthropic(model="claude-3-5-sonnet-20240620", temperature=0)
parser = PydanticOutputParser(pydantic_object=ResearchResponse)

prompt = ChatPromptTemplate.from_messages([
    ("system", 
    """You are a research assistant that will help the user with their research paper.
     Use the available tools to research the user's query thoroughly.
     
     IMPORTANT: Your final response must be ONLY valid JSON in the exact format specified below.
     Do not include any explanatory text before or after the JSON.
     Do not include duplicate keys in the JSON.
     Make sure all JSON is properly closed with matching braces and brackets.
     
     {format_instructions}"""),

    ("placeholder","{chat_history}"),
    ("human", "{query}"),
    ("placeholder", "{agent_scratchpad}"),
]
).partial(format_instructions=parser.get_format_instructions())

tools = get_research_tools()

agent = create_tool_calling_agent(
    llm,
    prompt = prompt, 
    tools=tools
)

def print_research_results(structured_response: ResearchResponse):
    """Print research results in a beautifully formatted way"""
    print("\nRESEARCH RESULTS")
    print(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Topic: {structured_response.topic}")
    
    # Summary section
    print("\nEXECUTIVE SUMMARY")
    print("-" * 50)
    print(f"{structured_response.summary}")
    
    # Key points section
    print(f"\nKEY INSIGHTS ({len(structured_response.key_points)} points)")
    print("-" * 50)
    for i, point in enumerate(structured_response.key_points, 1):
        print(f"{i:2d}. {point}")
    
    # Sources section
    if structured_response.sources:
        print(f"\nSOURCES ({len(structured_response.sources)} references)")
        print("-" * 50)
        for i, source in enumerate(structured_response.sources, 1):
            print(f"{i:2d}. {source}")
    
    print("\nResearch Complete.")
    print("Generated by Raworc Agent")

def save_results_to_json(structured_response: ResearchResponse, filename: str = None):
    """Save research results to a JSON file"""
    if filename is None:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"research_results_{timestamp}.json"
    
    # Create a modified version without tools_used and with attribution
    response_dict = structured_response.dict()
    response_dict.pop('tools_used', None)  # Remove tools_used if it exists
    response_dict['generated_by'] = 'Raworc Agent'
    
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(response_dict, f, indent=2, ensure_ascii=False)
    
    return filename

def save_results_to_text(structured_response: ResearchResponse, filename: str = None):
    """Save research results to a text file"""
    if filename is None:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"research_results_{timestamp}.txt"
    
    with open(filename, 'w', encoding='utf-8') as f:
        f.write("RESEARCH RESULTS\n")
        f.write("=" * 50 + "\n\n")
        f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"Topic: {structured_response.topic}\n\n")
        
        f.write("EXECUTIVE SUMMARY\n")
        f.write("-" * 30 + "\n")
        f.write(f"{structured_response.summary}\n\n")
        
        f.write(f"KEY INSIGHTS ({len(structured_response.key_points)} points)\n")
        f.write("-" * 30 + "\n")
        for i, point in enumerate(structured_response.key_points, 1):
            f.write(f"{i:2d}. {point}\n")
        f.write("\n")
        
        if structured_response.sources:
            f.write(f"SOURCES ({len(structured_response.sources)} references)\n")
            f.write("-" * 30 + "\n")
            for i, source in enumerate(structured_response.sources, 1):
                f.write(f"{i:2d}. {source}\n")
            f.write("\n")
        
        f.write("Research Complete.\n")
        f.write("\n" + "="*50 + "\n")
        f.write("Generated by Raworc Agent\n")
    
    return filename

def save_results_to_pdf(structured_response: ResearchResponse, filename: str = None):
    """Save research results to a PDF file"""
    if filename is None:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"research_results_{timestamp}.pdf"
    
    # Create PDF document
    doc = SimpleDocTemplate(filename, pagesize=A4)
    styles = getSampleStyleSheet()
    
    # Custom styles
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=18,
        spaceAfter=20,
        textColor='black'
    )
    
    heading_style = ParagraphStyle(
        'CustomHeading',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=12,
        textColor='black'
    )
    
    normal_style = styles['Normal']
    
    # Build content
    content = []
    
    # Title
    content.append(Paragraph("RESEARCH RESULTS", title_style))
    content.append(Spacer(1, 12))
    
    # Metadata
    content.append(Paragraph(f"<b>Generated:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", normal_style))
    content.append(Paragraph(f"<b>Topic:</b> {structured_response.topic}", normal_style))
    content.append(Spacer(1, 20))
    
    # Executive Summary
    content.append(Paragraph("EXECUTIVE SUMMARY", heading_style))
    content.append(Paragraph(structured_response.summary, normal_style))
    content.append(Spacer(1, 20))
    
    # Key Insights
    content.append(Paragraph(f"KEY INSIGHTS ({len(structured_response.key_points)} points)", heading_style))
    for i, point in enumerate(structured_response.key_points, 1):
        content.append(Paragraph(f"{i}. {point}", normal_style))
    content.append(Spacer(1, 20))
    
    # Sources
    if structured_response.sources:
        content.append(Paragraph(f"SOURCES ({len(structured_response.sources)} references)", heading_style))
        for i, source in enumerate(structured_response.sources, 1):
            content.append(Paragraph(f"{i}. {source}", normal_style))
        content.append(Spacer(1, 20))
    
    # Footer
    content.append(Spacer(1, 30))
    content.append(Paragraph("Research Complete.", normal_style))
    content.append(Spacer(1, 20))
    content.append(Paragraph("Generated by Raworc Agent", normal_style))
    
    # Build PDF
    doc.build(content)
    
    return filename

def offer_download_options(structured_response: ResearchResponse):
    """Offer download options to the user"""
    print("\nDownload Options:")
    print("1. JSON file")
    print("2. Text file (.txt)")
    print("3. PDF file")
    print("4. All formats")
    print("5. Skip download")
    
    while True:
        choice = input("\nSelect download option (1-5): ").strip()
        
        if choice == "1":
            filename = save_results_to_json(structured_response)
            print(f"JSON file saved: {filename}")
            break
        elif choice == "2":
            filename = save_results_to_text(structured_response)
            print(f"Text file saved: {filename}")
            break
        elif choice == "3":
            try:
                filename = save_results_to_pdf(structured_response)
                print(f"PDF file saved: {filename}")
            except Exception as e:
                print(f"Error creating PDF: {e}")
                print("Falling back to text file...")
                filename = save_results_to_text(structured_response)
                print(f"Text file saved: {filename}")
            break
        elif choice == "4":
            files_saved = []
            
            # Save JSON
            json_file = save_results_to_json(structured_response)
            files_saved.append(json_file)
            
            # Save Text
            text_file = save_results_to_text(structured_response)
            files_saved.append(text_file)
            
            # Save PDF
            try:
                pdf_file = save_results_to_pdf(structured_response)
                files_saved.append(pdf_file)
            except Exception as e:
                print(f"Error creating PDF: {e}")
            
            print(f"Files saved: {', '.join(files_saved)}")
            break
        elif choice == "5":
            print("Download skipped.")
            break
        else:
            print("Invalid choice. Please select 1-5.")

def conduct_research(query: str):
    """Conduct research on a given query and return formatted results"""
    print("Starting research agent...")
    print(f"Processing query: '{query}'")
    print("-" * 80)

    agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=False)  # Set verbose=False for cleaner output
    raw_response = agent_executor.invoke({"query": query})

    # Debug: Print the raw response structure
    print(f"\nDEBUG - Raw response type: {type(raw_response)}")
    print(f"DEBUG - Raw response keys: {raw_response.keys() if isinstance(raw_response, dict) else 'Not a dict'}")
    
    # AgentExecutor returns the final output in the 'output' key
    output_text = raw_response.get("output", "")
    
    # Handle case where output might be a list
    if isinstance(output_text, list) and len(output_text) > 0:
        if isinstance(output_text[0], dict) and 'text' in output_text[0]:
            output_text = output_text[0]['text']
        else:
            output_text = str(output_text[0])
    
    print(f"DEBUG - Output text type: {type(output_text)}")
    print(f"DEBUG - Output text preview: {str(output_text)[:200]}...")

    try:
        structured_response = parser.parse(output_text)
        
        # Print beautifully formatted results
        print_research_results(structured_response)
        
        # Offer download options
        offer_download_options(structured_response)
        
        return structured_response
        
    except Exception as e:
        print("\nERROR OCCURRED during parsing")
        print(f"Error: {e}")
        
        # Try to create a fallback structured response
        try:
            print("\nAttempting fallback response creation...")
            
            # Create a basic structured response from raw text
            fallback_response = create_fallback_response(output_text, query)
            
            if fallback_response:
                print("\nFallback response created successfully!")
                print_research_results(fallback_response)
                offer_download_options(fallback_response)
                return fallback_response
            
        except Exception as fallback_error:
            print(f"Fallback also failed: {fallback_error}")
        
        print("\nRaw output received:")
        print("-" * 30)
        print(output_text)
        print("-" * 30)
        print("\nDebug info:")
        print(repr(output_text))
        
        # Offer to save raw output
        save_raw = input("\nWould you like to save the raw output as text? (y/n): ").strip().lower()
        if save_raw in ['y', 'yes']:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"raw_output_{timestamp}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(f"Query: {query}\n")
                f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("="*50 + "\n\n")
                f.write(str(output_text))
            print(f"Raw output saved to: {filename}")
        
        return None

def create_fallback_response(raw_text: str, query: str) -> ResearchResponse:
    """Create a fallback structured response from raw text"""
    
    # Clean the raw text
    if isinstance(raw_text, str):
        text = raw_text.strip()
    else:
        text = str(raw_text).strip()
    
    # Basic fallback structure
    fallback = ResearchResponse(
        topic=query[:100] + "..." if len(query) > 100 else query,
        summary=text[:500] + "..." if len(text) > 500 else text,
        key_points=[
            "Raw research data retrieved from Wikipedia",
            "Manual processing may be required for detailed analysis",
            "Content extracted from AI research agent"
        ],
        sources=["Wikipedia API"],
        tools_used=[]
    )
    
    return fallback

def get_user_query():
    """Get research query from user with better input handling"""
    print("\nResearch Query Input")
    print("-" * 50)
    print("Tips:")
    print("   • Be specific about what you want to research")
    print("   • You can ask multiple questions in one query")
    print("   • Examples: 'How does blockchain work?', 'Compare Python vs Java'")
    
    while True:
        query = input("\nEnter your research question: ").strip()
        
        if not query:
            print("Error: Query cannot be empty. Please enter a valid research question.")
            continue
            
        if len(query) < 10:
            print("Error: Query too short. Please provide more details (at least 10 characters).")
            continue
            
        # Confirm the query
        print(f"\nYour query: '{query}'")
        confirm = input("Proceed with this query? (y/n): ").strip().lower()
        
        if confirm in ['y', 'yes', '']:
            return query
        elif confirm in ['n', 'no']:
            print("Let's try again...")
            continue
        else:
            print("Please enter 'y' for yes or 'n' for no.")

def display_menu():
    """Display the main menu"""
    print("\nResearch Agent - Main Menu")
    print("1. Custom Research Query")
    print("2. Demo Query (Generative AI vs LLM)")
    print("3. Exit")

def main():
    """Main function to run the research agent"""
    print("Welcome to the AI Research Agent")
    print("Powered by Raworc")
    
    while True:
        display_menu()
        
        try:
            choice = input("\nSelect an option (1-3): ").strip()
            
            if choice == "1":
                query = get_user_query()
                conduct_research(query)
                
            elif choice == "2":
                print("\nRunning demo query...")
                default_query = "What is generative AI and how does it work? What is the difference between generative AI and large language models?"
                conduct_research(default_query)
                
            elif choice == "3":
                print("\nThank you for using the Research Agent!")
                print("Happy researching!")
                break
                
            else:
                print("Invalid choice. Please select 1, 2, or 3.")
                continue
                
        except KeyboardInterrupt:
            print("\n\nResearch interrupted by user.")
            print("Thank you for using the Research Agent!")
            break
        except Exception as e:
            print(f"\nUnexpected error: {e}")
            print("Please try again...")
            continue
        
        # Ask if user wants to continue
        continue_choice = input("\nWould you like to conduct another research? (y/n): ").strip().lower()
        if continue_choice not in ['y', 'yes', '']:
            print("\nThank you for using the Research Agent!")
            print("Happy researching!")
            break

if __name__ == "__main__":
    main()
